{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = tzParseTimezone;\n\nvar _index = _interopRequireDefault(require(\"../tzTokenizeDate/index.js\"));\n\nvar _index2 = _interopRequireDefault(require(\"../newDateUTC/index.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-]\\d{2})$/,\n  timezoneHHMM: /^([+-]\\d{2}):?(\\d{2})$/\n}; // Parse various time zone offset formats to an offset in milliseconds\n\nfunction tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token;\n  var absoluteOffset; // Empty string\n\n  if (timezoneString === '') {\n    return 0;\n  } // Z\n\n\n  token = patterns.timezoneZ.exec(timezoneString);\n\n  if (token) {\n    return 0;\n  }\n\n  var hours; // ±hh\n\n  token = patterns.timezoneHH.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n\n    if (!validateTimezone(hours)) {\n      return NaN;\n    }\n\n    return -(hours * MILLISECONDS_IN_HOUR);\n  } // ±hh:mm or ±hhmm\n\n\n  token = patterns.timezoneHHMM.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n    var minutes = parseInt(token[2], 10);\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN;\n    }\n\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    return hours > 0 ? -absoluteOffset : absoluteOffset;\n  } // IANA time zone\n\n\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now());\n    var utcDate = isUtcDate ? date : toUtcDate(date);\n    var offset = calcOffset(utcDate, timezoneString);\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n    return -fixedOffset;\n  }\n\n  return NaN;\n}\n\nfunction toUtcDate(date) {\n  return (0, _index2.default)(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\n\nfunction calcOffset(date, timezoneString) {\n  var tokens = (0, _index.default)(date, timezoneString); // ms dropped because it's not provided by tzTokenizeDate\n\n  var asUTC = (0, _index2.default)(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();\n  var asTS = date.getTime();\n  var over = asTS % 1000;\n  asTS -= over >= 0 ? over : 1000 + over;\n  return asUTC - asTS;\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime(); // Our UTC time is just a guess because our offset is just a guess\n\n  var utcGuess = localTS - offset; // Test whether the zone matches the offset for this ts\n\n  var o2 = calcOffset(new Date(utcGuess), timezoneString); // If so, offset didn't change, and we're done\n\n  if (offset === o2) {\n    return offset;\n  } // If not, change the ts by the difference in the offset\n\n\n  utcGuess -= o2 - offset; // If that gives us the local time we want, we're done\n\n  var o3 = calcOffset(new Date(utcGuess), timezoneString);\n\n  if (o2 === o3) {\n    return o2;\n  } // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n\n\n  return Math.max(o2, o3);\n}\n\nfunction validateTimezone(hours, minutes) {\n  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);\n}\n\nvar validIANATimezoneCache = {};\n\nfunction isValidTimezoneIANAString(timeZoneString) {\n  if (validIANATimezoneCache[timeZoneString]) return true;\n\n  try {\n    Intl.DateTimeFormat(undefined, {\n      timeZone: timeZoneString\n    });\n    validIANATimezoneCache[timeZoneString] = true;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/matthewvolny/Desktop/DigitalCrafts/Displayed-Projects/Crypto-App/node_modules/date-fns-tz/_lib/tzParseTimezone/index.js"],"names":["Object","defineProperty","exports","value","default","tzParseTimezone","_index","_interopRequireDefault","require","_index2","obj","__esModule","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","patterns","timezone","timezoneZ","timezoneHH","timezoneHHMM","timezoneString","date","isUtcDate","token","absoluteOffset","exec","hours","parseInt","validateTimezone","NaN","minutes","Math","abs","isValidTimezoneIANAString","Date","now","utcDate","toUtcDate","offset","calcOffset","fixedOffset","fixOffset","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","tokens","asUTC","getTime","asTS","over","localTS","utcGuess","o2","o3","max","validIANATimezoneCache","timeZoneString","Intl","DateTimeFormat","undefined","timeZone","error","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = tzParseTimezone;\n\nvar _index = _interopRequireDefault(require(\"../tzTokenizeDate/index.js\"));\n\nvar _index2 = _interopRequireDefault(require(\"../newDateUTC/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar MILLISECONDS_IN_HOUR = 3600000;\nvar MILLISECONDS_IN_MINUTE = 60000;\nvar patterns = {\n  timezone: /([Z+-].*)$/,\n  timezoneZ: /^(Z)$/,\n  timezoneHH: /^([+-]\\d{2})$/,\n  timezoneHHMM: /^([+-]\\d{2}):?(\\d{2})$/\n}; // Parse various time zone offset formats to an offset in milliseconds\n\nfunction tzParseTimezone(timezoneString, date, isUtcDate) {\n  var token;\n  var absoluteOffset; // Empty string\n\n  if (timezoneString === '') {\n    return 0;\n  } // Z\n\n\n  token = patterns.timezoneZ.exec(timezoneString);\n\n  if (token) {\n    return 0;\n  }\n\n  var hours; // ±hh\n\n  token = patterns.timezoneHH.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n\n    if (!validateTimezone(hours)) {\n      return NaN;\n    }\n\n    return -(hours * MILLISECONDS_IN_HOUR);\n  } // ±hh:mm or ±hhmm\n\n\n  token = patterns.timezoneHHMM.exec(timezoneString);\n\n  if (token) {\n    hours = parseInt(token[1], 10);\n    var minutes = parseInt(token[2], 10);\n\n    if (!validateTimezone(hours, minutes)) {\n      return NaN;\n    }\n\n    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    return hours > 0 ? -absoluteOffset : absoluteOffset;\n  } // IANA time zone\n\n\n  if (isValidTimezoneIANAString(timezoneString)) {\n    date = new Date(date || Date.now());\n    var utcDate = isUtcDate ? date : toUtcDate(date);\n    var offset = calcOffset(utcDate, timezoneString);\n    var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n    return -fixedOffset;\n  }\n\n  return NaN;\n}\n\nfunction toUtcDate(date) {\n  return (0, _index2.default)(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\n\nfunction calcOffset(date, timezoneString) {\n  var tokens = (0, _index.default)(date, timezoneString); // ms dropped because it's not provided by tzTokenizeDate\n\n  var asUTC = (0, _index2.default)(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();\n  var asTS = date.getTime();\n  var over = asTS % 1000;\n  asTS -= over >= 0 ? over : 1000 + over;\n  return asUTC - asTS;\n}\n\nfunction fixOffset(date, offset, timezoneString) {\n  var localTS = date.getTime(); // Our UTC time is just a guess because our offset is just a guess\n\n  var utcGuess = localTS - offset; // Test whether the zone matches the offset for this ts\n\n  var o2 = calcOffset(new Date(utcGuess), timezoneString); // If so, offset didn't change, and we're done\n\n  if (offset === o2) {\n    return offset;\n  } // If not, change the ts by the difference in the offset\n\n\n  utcGuess -= o2 - offset; // If that gives us the local time we want, we're done\n\n  var o3 = calcOffset(new Date(utcGuess), timezoneString);\n\n  if (o2 === o3) {\n    return o2;\n  } // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n\n\n  return Math.max(o2, o3);\n}\n\nfunction validateTimezone(hours, minutes) {\n  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);\n}\n\nvar validIANATimezoneCache = {};\n\nfunction isValidTimezoneIANAString(timeZoneString) {\n  if (validIANATimezoneCache[timeZoneString]) return true;\n\n  try {\n    Intl.DateTimeFormat(undefined, {\n      timeZone: timeZoneString\n    });\n    validIANATimezoneCache[timeZoneString] = true;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}